name: Release (cargo-release)

on:
  # Create releases when pushing tags like `<crate>-v0.1.0` or `v0.1.0`
  push:
    tags:
      - 'v*'
      - '*-v*'
  workflow_dispatch:
    inputs:
      ref:
        description: "Git ref (tag or branch) to checkout for publishing (defaults to current ref on tag push)"
        required: false
        type: string
      packages:
        description: "Comma-separated list of crates to publish (optional; defaults to all workspace crates)"
        required: false
        type: string
      level:
        description: "Version bump level for cargo-release (patch | minor | major). Default: patch"
        required: false
        type: string

permissions:
  contents: write

jobs:
  prepare-and-release:
    name: Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # On workflow_dispatch, allow checking out a specific ref/tag if provided.
          ref: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.ref != '' && github.event.inputs.ref || github.ref }}

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@v1
        with:
          toolchain: stable
          components: clippy

      - name: Cache cargo
        uses: Swatinem/rust-cache@v2

      - name: Install cargo-release
        run: cargo install cargo-release --locked

      - name: Verify workspace (clippy + tests)
        run: |
          cargo clippy --workspace --all-features -- -Dwarnings
          cargo test --workspace --all-features --no-fail-fast

      - name: Dry-run release (no token)
        if: ${{ env.CARGO_REGISTRY_TOKEN == '' }}
        env:
          LEVEL: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.level != '' && github.event.inputs.level || 'patch' }}
        run: |
          # Determine release version from tag when this workflow runs on a tag push.
          RELEASE_VERSION=""
          if [ "${{ github.event_name }}" = "push" ]; then
            TAG_NAME="${GITHUB_REF_NAME}"
            if [[ "$TAG_NAME" =~ ^v(.+)$ ]]; then
              RELEASE_VERSION="${BASH_REMATCH[1]}"
            elif [[ "$TAG_NAME" =~ -v(.+)$ ]]; then
              RELEASE_VERSION="${BASH_REMATCH[1]}"
            fi
          fi
          CARGO_RELEASE_ARG="${RELEASE_VERSION:-${LEVEL}}"
          echo "No crates.io token found; running cargo-release dry-run for verification only (arg=${CARGO_RELEASE_ARG})."
          cargo release "${CARGO_RELEASE_ARG}" --workspace --no-confirm --dry-run --no-publish

      - name: "Publish crates to crates.io (skip if version already published)"
        if: ${{ env.CARGO_REGISTRY_TOKEN != '' }}
        env:
            CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
            GIT_COMMITTER_NAME: github-actions[bot]
            GIT_COMMITTER_EMAIL: 41898282+github-actions[bot]@users.noreply.github.com
            LEVEL: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.level != '' && github.event.inputs.level || 'patch' }}
        run: |
            # Determine candidate package list: use input `packages` if provided; otherwise default to all workspace crates.
            CANDIDATES=()
            if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.packages }}" ]; then
              IFS=',' read -ra PKGS <<< "${{ github.event.inputs.packages }}"
              for p in "${PKGS[@]}"; do
                p_trimmed=$(echo "$p" | xargs)
                [ -n "$p_trimmed" ] && CANDIDATES+=("$p_trimmed")
              done
            else
              CANDIDATES+=(
                storeit_core
                storeit_macros
                storeit_sql_builder
                storeit_libsql
                storeit_mysql_async
                storeit_tokio_postgres
                storeit
              )
            fi

            # Filter out crates that are already published at the current version on crates.io
            # Note: cargo-release errors when trying to publish an already-published version.
            FILTERED=()
            for crate in "${CANDIDATES[@]}"; do
              manifest_path="${crate}/Cargo.toml"
              if [ ! -f "$manifest_path" ]; then
                echo "Warning: manifest not found for $crate at $manifest_path; skipping"
                continue
              fi
              # Extract version = "x.y.z" from the [package] section
              ver=$(grep -m1 -E '^version\s*=\s*"' "$manifest_path" | sed -E 's/.*"([^"]+)".*/\1/')
              if [ -z "$ver" ]; then
                echo "Warning: could not determine version for $crate; keeping it in the list"
                FILTERED+=("$crate")
                continue
              fi
              http_code=$(curl -s -o /dev/null -w "%{http_code}" "https://crates.io/api/v1/crates/${crate}/${ver}") || http_code=000
              if [ "$http_code" = "200" ]; then
                echo "Info: $crate $ver already published on crates.io; skipping"
              else
                FILTERED+=("$crate")
              fi
            done

            if [ ${#FILTERED[@]} -eq 0 ]; then
              echo "Nothing to publish; all selected crates are already on crates.io"
              exit 0
            fi

            # Note: We run on a tag checkout for push-tag events; for workflow_dispatch, we checkout `inputs.ref`.
            # We avoid remote VCS mutations (--no-tag/--no-push). Commits (if any) wonâ€™t be pushed.
            set -euo pipefail

            # Determine release version from tag if present
            RELEASE_VERSION=""
            if [ "${{ github.event_name }}" = "push" ]; then
              TAG_NAME="${GITHUB_REF_NAME}"
              if [[ "$TAG_NAME" =~ ^v(.+)$ ]]; then
                RELEASE_VERSION="${BASH_REMATCH[1]}"
              elif [[ "$TAG_NAME" =~ -v(.+)$ ]]; then
                RELEASE_VERSION="${BASH_REMATCH[1]}"
              fi
            fi
            CARGO_RELEASE_ARG="${RELEASE_VERSION:-${LEVEL}}"
            echo "Using cargo-release argument: ${CARGO_RELEASE_ARG}"
            # Run cargo-release per crate so we can gracefully handle already-published versions
            # Write logs outside the repo to avoid creating untracked files that make the workspace dirty.
            LOG_DIR="${RUNNER_TEMP:-/tmp}/cargo-release-logs"
            mkdir -p "$LOG_DIR"
            for crate in "${FILTERED[@]}"; do
              echo "Bumping and publishing $crate..."
              LOG_FILE="$LOG_DIR/publish_${crate}.log"
              # Run and capture output; allow command to fail so we can inspect
              set +e
              cargo release "${CARGO_RELEASE_ARG}" --no-confirm --execute \
                --allow-branch HEAD \
                --no-verify \
                --no-tag \
                --no-push \
                --package "$crate" 2>&1 | tee "$LOG_FILE"
              status=${PIPESTATUS[0]}
              set -e
              if [ $status -ne 0 ]; then
                if grep -q "is already published" "$LOG_FILE"; then
                  echo "Info: $crate is already published; skipping."
                  continue
                else
                  echo "Error: cargo-release failed for $crate. See $LOG_FILE"
                  exit $status
                fi
              fi
            done
            echo "Finished publishing selected crates."
      

      - name: Create GitHub Release (draft)
        if: ${{ github.event_name == 'push' }}
        uses: softprops/action-gh-release@v2
        with:
          draft: true
          generate_release_notes: true
